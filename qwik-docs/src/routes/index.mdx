---
slug: getting-started
---
import Notes from '~/components/template/notes'
import Warning from '~/components/template/warning'

At the heart of ZeUnit sits a simple design principle; a test is a function and functions return result(s). For ZeUnit that result is a `Fact` which reports back to the test runner.  The benfits?   

- Control over the life-cycle
- Class activation for DI
- Custom method bindings
- Test reporting & result sinks 

<Notes title="Follow Along">
Jump into the [Getting Started](/docs/getting-started/) guide to follow along on your local computer.
</Notes>


## Barebones Test

The example above in the `BarebonesSuite`, is the most basic form that of a test in ZeUnit.  There is no constructor injection or custom method bindings.  As a result it defaults to `TransientSuite` with a `TransientLifecycleFactory` for the class lifecycle.

The test itself at the low level boils down to a simple assertion: `return value == "expected";`.   With little help from <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators" target="_blank">implicit type operators</a> magic the `bool` is converted to a `Fact<bool>` allowing the code to compile and the test to report results. 

<Notes>
A secondary implicit convertion operator is also created on `Tuple<bool, string>` to support custom messages to be returned along with the tests status.
</Notes>

```csharp
public class BarebonesSuite : TransientSuite
 {
     public Fact GetExpectedValueWithMessage()
     {       
         return (actual == "expected", $"Expected value does not match {actual}!!");
     }
 }
```

<Notes>
The example above explicitly definces the lifecycle by inheriting from the `TransientSuite` class, this the defualt behavior for classes that don't inherit a Suite class.
</Notes>

## Adding Assertions

While the shorthand `bool` and `Tuple<bool, string>` are useful for quick and dirty tests, a simple pass/fail fails to give enough details for troubleshooting, and having to write out custom messages for every test would become very tedious.  This is where `ZeUnit.Assertions` namespace shines.  The <a href="https://docs.shouldly.org/documentation/getting-started" target="_blank">Shouldly</a> inspired collection of helpers supercharge the testing process.

```csharp
public class AssertionSuite
 {
     public Fact GetExpectedValue()
     {   
         var actual = GetSomeString();    
         return actual
            .IsNotNull()
            .IsType<string>()
            .Is("expected");
     }
 }
``` 

A similar test could be written using the `bool` but would require that it be broken into 3 seperate tests or that the test returns the type `IEnumerable<Fact>` allowing for `yield return` syntax for multiple assertions.

The other added value in using the assertion library over the shorthand `bool` tests is the rich reporting on the objects under tests.  Something that is lost when implicity converting from `bool` to `Fact`.

## The Kitchen Sink

The `TheKitchenSinkSuite` class really showcases the power of ZeUnit to create many tests with very few lines of code.  Out the gate there are two attributes that define the attributes that are used for class composition to fulfill the test class dependecies.  

- The `Singleton` attribute creates a single instance of a value to be shared by all the test that inject the values.  More on this shortly.
- The `LamarContainer` attribute creates a DI container and registers the `CalculatorRegistry` to the container allowing the `ICalculator` to be injected into the class.

<Notes>
These attributes are just a taste of what can be done before the test is executed by creating domain specific attributes unique to your project by overriding `ZeClassComposer` and ZeComposerAttribute` classes.  See more [Class Composers](/docs/core-class-composers/) or [Custom Class Composers](/docs/building-class-composers/).
</Notes>

```csharp
[Singleton(typeof(SingletonCounter))]
[LamarContainer(typeof(CalculatorRegistry))]
public class TheKitchenSinkSuite
{
    private readonly ICalculator calculator;
    private readonly SingletonCounter counter;

    public TheKitchenSinkSuite(ICalculator calculator, SingletonCounter counter)
    {
        this.calculator = calculator;
        this.counter = counter;
    }

    [InlineData(null, 0)]
    [InlineData(new[] { 1d }, 1)]
    [InlineData(new[] { 1d, 2d }, 3)]
    [InlineData(new[] { 1d, 2d, 3d, 4d }, 10)]
    public Fact AdditionHarness(double[] values, double expected)
    {            
        var actual = this.calculator.Apply<AddOperation>(values);
        counter.Increment();
        return actual.Is(expected);
    }    
}
```
The `InlineData` is a familiar tool of existing unit testing frameworks, but just like the `ZeClassComposer` customizations ZeUnit focuses on making custom method bindings easy to create.  More on this in the [Method Bindings](/docs/core-method-binders/) section.

Back to the single instance of `SingletonCounter` which might seem out of place in a test suite that is transient.  However, when building a testing framework on top of reactive IObservable classes, being able to build out dependency chains for behaviors becomes pretty trivial.  For the purists this is a unit test code smell, but as ZeUnit scales to larger integration and end-to-end tests, the ability to share state between tests that can follow each other becomes a powerful tool.

<Warning>
The features around `DependsOn` are not currently implemented in the current version of ZeUnit.  They are planned for a future release.
</Warning>

- `[DependsOn("AddOneMoreFirst")]` is doing some interesting work allowing us to define that some tests in the suite have to run before others by creating a dependency.
- `[DependsOn(typeof(TheKitchenSinkSuite))]` is a way to define that `NextKitchenSinkSuite` depends on `TheKitchenSinkSuite` to be run first 


```csharp
[DependsOn(typeof(TheKitchenSinkSuite))]
[Singleton(typeof(SingletonCounter))]
public class NextKitchenSinkSuite     
{    
    private readonly SingletonCounter counter;

    public TheKitchenSinkSuite(SingletonCounter counter)
    {        
        this.counter = counter;
    }

    public Fact AddOneMoreFirst()
    {            
        counter.Increment();
        return true;
    }    

    [DependsOn("AddOneMoreFirst")]
    public Fact CheckTotalValue()
    {                    
        return counter.Value() == 5;
    }    
}
```

### Understanding The Lifecycle 

The outcome here is that `TheKitchenSinkSuite` is run first, thereby allowing each of the `InlineData` method bindings to excute the `AdditionHarness` method.  This keeps incrementing the `SingletonCounter` and which is always the same despite `TheKitchenSinkSuite` being transient for each instance of the method binding.

Once all of tests in `TheKitchenSinkSuite` the dependecy defined on `NextKitchenSinkSuite` with the `IZeDependency<TheKitchenSinkSuite>` interface is satified and ZeUnit will pick up the Facts.  The lifecycle of this class however is modified by inheritence from the `OrderedSuite<NextKitchenSinkOrder>` which deferrs figuring out method fact dependencies as a `SuiteOrder` class.

Behind the scenes the `SuiteOrder` wraps `IObserable` magic, allowing tests to shake out dependecies as they complete.  The pseudo code definition in the none functional example above would require that the Fact `AddOneMoreFirst` is run before `CheckTotalValue` is run.  This makes the Counter value 5 and the finally test pass.

---

Next Section: [Testing a Calculator](/docs/testing-a-calculator/)