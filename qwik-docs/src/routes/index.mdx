---
slug: why-zeunit
---
import Notes from '~/components/template/notes'
import Warning from '~/components/template/warning'
import Card from '~/components/template/card'
import TwoColumns from '~/components/template/two-columns'
import { HiCheckCircleMini, HiShieldCheckSolid, HiPrinterMini, HiCog8ToothSolid } from "@qwikest/icons/heroicons";


## What is ZeUnit?

ZeUnit is the vision of a unified mental model for testing, smoothing the difference between unit, integration and end-to-end tests with progression of progressive enhancement of extensable framework features.  This unified approach not only simplifies the testing process but also fosters a consistent and cohesive testing strategy across your project.

 <TwoColumns>
    <Card title='Simple & Functional'>
        <HiCheckCircleMini q:slot='icon' />
        ZeUnit embodies the ideals of functional programming, treating each test as a function that [return a result](/docs/returning-results). This approach ensures composability and seamlessly resuability as your project grows.
    </Card>
    <Card title='Scaling to Integration Testing'>
        <HiShieldCheckSolid q:slot='icon' />
        Armed with [class composers](/docs/core-class-composers) and [method binders](/docs/core-method-binders)  ZeUnit scales to handling requirements of dependencies and testing data while keeping to the same consitent testing syntax.
    </Card>
    <Card title='Tailored Reporting'>
        <HiPrinterMini q:slot='icon' />
       Visual [stunning reports](/docs/core-reporting) from ZeUnit provide early deliverables to stakeholders, allowing for low-effort user experience (UX) testing during greenfield project development.
    </Card>
    <Card title='Powerfully Adaptable'>
        <HiCog8ToothSolid q:slot='icon' />
        ZeUnit is readily extensible, allowing developers to tailor the test projects to a specific busiens domain with roll-your-own classes to customize [assertions](/docs/facts-and-assertions), [class composers](/docs/building-class-composers), [method binders](/docs/building-method-binders) and even [test life-cycles](/docs/test-suite-lifecycle).
    </Card>
</TwoColumns>


## Why ZeUnit?

**ZeUnit** was born from the frustrations with the existing integration test tooling.  While the vast field of tools and framework offerings all very in the approach, a common theme across the frameworks is the inherent misunderstanding about the target audience of these tools.

<Warning title="The Flawed Assumption">
Anyone besides software engineers will write integration/acceptance tests. 
</Warning>

**If only** the markdown is **simple enough**, business people will **metamorph** in software engineers.  The sales pitch for any individual integration frameworks always boils down to **"Our markdown is simple enough!!!"**, but the harsh reality is that it is inevitably an engineer that write the tests. But now, handcuffed by the **"simple" markdown** instead of being empowered by **general purpose** language.

To walk back the combative connotation against business folk, the expectation that business people would write markdown ( a.k.a. "code" ) is outlandish!  Business people don't write code, **engineers write code**, **business people crete the data**.  

<Notes title="Its the Data not Tests">
**Data is the obvious handshake** between engineers who write the tests and the business people who create requirements.
</Notes>

Now with that vision in mind, the idea behind ZeUnit began to hatch.  Build an integration framework with out the ðŸ¥’ or other markdown files, and let dotnet developers do what they do best; write tests in C#.  

Along the way experiments turned into proofs of concept, proofs of concept turned into working prototypes and those prototypes turned into ZeUnit.  The result is a framework that tries to bring **functional programming** and element of **composition** to make testing more **repeatable** and **easier to scale** al the while keeping a **consistent mental model* across all scales of testing.

## Unit vs. Integration vs. End-to-End

How big is a unit test? How big is an integration test? How big is end-to-end or smoke tests? Probably all bigger than a breadbox, except maybe the unit test, they should be pretty damn small!

<Notes title="For the Tech-heads">
Tired of all the "blah blah blah" and *"philosophy"* of testing? Need to get down to the nitty & gritty code? 

- Skip ahead to [birdseye view](/docs/birdseye-view/) and get a feeling for the different scale of testing with code examples.  
- Also see the [getting-started](/docs/getting-started/) guide to start writing your own ZeUnit tests in your projects.
</Notes>

The book <a href="https://amzn.to/3G4e4V4" target="_blank">How Google Tests Software</a> talks about a system of test classification that doesn't neatly fit into the bucket of unit or integration testing.  Google instead classifies their tests as small, medium or large.  With that said when looking at the testing tools, there existing duality.

* **Unit Testing** - in dotnet, this would be <a href="https://xunit.net/" target="_blank">XUnit</a> or <a href="https://nunit.org/" target="_blank">NUnit</a>, both of which focus on small scale testing and don't come with tools that enable contextual state.  
* **Integration Testing** - these would be your <a href="https://specflow.org/" target="_blank">SpecFlow</a>, <a href="https://fitnesse.org/" target="_blank">Fitnesse</a> and <a href="https://storyteller.github.io/" target="_blank">StoryTeller</a>.  At the abstract layer, these frameworks enable some kind of system state abstracted behind a fixture.  These are the tools that sell the big lie of the "The Flawed Assumption".

But what if that distinction is less important than the weight it is given today.  ZeUnit straddles the line between those worlds offering a simple syntax for writing pure unit tests and exposing a path of progressive enhancement that can scale test complexity and size.  The goal is a single language across your entire test suite.   

- Is your test **"Small"**? It probably has no dependencies and lives inside a `TransientSuite` [lifecycle](/docs/test-suite-lifecycle/). At this scale there might be value to extending the tests with some [method binders](/docs/core-method-binders/) to test reuse with method re-entry.  The [fakes-composer](/case-study/fakes-composer/) case-study offers helpful walk-through of the elements of [class composition](/docs/core-class-composers/), which could be pushing the limits of the **unit** test breadbox.
- For **"Medium"** size tests, parts of the system will need to be in-place for the tests to run correctly.  This is where [class composition](/docs/core-class-composers/) really starts to shine.  Composers built around the [DI containers](/docs/lamar-dependency-injection/) of choice can consume the same modules used by the application to create containers unique to the test.
- Getting upt to **"Large"** tests? Test might need to execute as a [specific chains of events](/docs/test-dependency-chain/) and generate meaningful [reporting data](/docs/core-reporting/) that shared with a larger audiences.

The simpler mental model comes down to composition of dependencies and a function that a `Fact` [assertion](/docs/facts-and-assertions) no matter the scale of the test.
 
## Tests, A Developers Best Friend & Worst Enemy

A common trope, at least on [r/dotnet](https://www.reddit.com/r/dotnet/) is lack of testing out in the business world.  The lack of testing is often a result of the lack of time to write tests, or the lack of understanding of the value of tests.  This is truly one of the most "shoot your self in the foot" moments in software engineering. Inevitably the lack of testing leads to a scurry of manual testing and likely slipped deadlines, which only re-enforces the idea that there is not enough time to write tests.

The truth is that testing isn't easy, and while it is a powerful tool in the developer toolbox few developers are well practiced with it.  Moreover hard "code coverage" numbers are often seen as hurdles to clear rather than a standard to strive for.

Here are some warning signs that engineers don't understand the value of tests:

### Long tests with many assertions.

Cover coverage standards are often tracked by ci/cd automation, the game the system developers writing end-to-end tests under the flag of writing unit tests resulting in high coverage with very few tests. The outcome is a false sense of security and a mole hunt when one of those tests fails.

<Warning title="End-to-End Canary Tets">
The value of a good suite of small fine grained tests is that test failures point to specific areas of the code reducing the time to troubleshoot and address future issues.  When a test failure means that something, somewhere, at some time might be broken, that is no better than a canary flagging the entire mine as unsafe.
</Warning>

### End of development test crunch.

*"I am finishing up the feature by writing tests."* is a trope of an agile standup conversation. The question arises, can it be known how finished a feature is if it is untested? 

Tests are not an afterthought, they are the checklist along the way to validate that how you think the computer will understand you is how the computer actually understands you. It is there to test your assumptions before too any assumptions are stacked on top each other and it is impossible to know which untested assumption is the root cause of the problem.

### Long refactoring times due to breaking tests

This is where ZeUnit really breaks the mold with the other forms of testing and brings the re-usability to all scales of testing.  The "DRY" montra so prevelent in all aspects of software engineering is looked down on when applying it to testing.  To the test purist, ZeUnit is an abomination because it isn't shackled to the "Assemble, Act, Assert" dogma of unit testing.  At least, the "Assemble" element of the trinity is abstracted away behind the custom class composers or method binders which are re-used from test to test.

***

Next Section: [Birdseye View](/docs/birdseye-view/)