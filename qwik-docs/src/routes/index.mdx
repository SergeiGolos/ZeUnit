---
slug: getting-started
---
import Notes from '~/components/template/notes'
import Warning from '~/components/template/warning'

At the heart of ZeUnit sits a simple principle. A test is a function; and functions return result(s). `Fact` in the case of ZeUnit.  The benfits?   

- Control over the life-cycle
- Custom class and method level activations
- Test middleware for wrapping test execution and reporting

<Notes title="Follow Allong">
Jump into the [Getting Started](/docs/getting-started/) guide to follow allong on your local computer.
</Notes>


## Barebones Test

The example above `BarebonesSuite`, is the most basic form that a test suite can take.  The example has no dependecies on the class or method level activators, no middleware like a global bag, special reporting or suite lifecycles.  At the very low level, this test defaults to single test activation on a transient instace of the the test class.  More over the test itself is uing the default notation `return value == "expected";` which is like saying `return true;` and `true` is not exactly a `Fact` that is being loaded.  With the magic of [implicit type operators](link needed) the `bool` is converted to a `Fact` allowing the code to compile and under the hood doing a `.True(string? message = null)` assertion on the value we are implicity converting into a `Fact<bool>`.  A secondary implicit convertion operator is also created on `Tuple<bool, string>` to suppor custom test messages in this barebones mode of the library to populate the optional `message` argument in a `True()` assertion. 

## Adding Assertions

While the shortand `bool` and `(bool, string)` are useful for quick and dirty tests, this isn't enough for real world testing.  What is missing? 

- automatic rich messages
- multi assertion messages
- test specific behvaiors

Techinally, the function can return `new Fact(object actual)` with specific calls to assertion to attach messgaes, and in some very special cases it might be the way to go, but as it is combusrome and instead ZeUnit borrow from shoudly and fluient assertions for syntax like `Is(expected)` and `IsType<TType>()` shortands for creating `Fact` objects but also automatically generate rich messages on failure when the conditions are met.  

```csharp
public class AssertionSuite
 {
     public Fact GetExpectedValue()
     {   
         var actual = GetSomeString();    
         return actual
            .IsNotNull()
            .IsType<string>()
            .Is("expected");
     }
 }
``` 

## The Kittche Sink

<Warning title="Experemental Code">
The following code is experemental and not yet supported in the current version of ZeUnit.  It is a preview of what is to come in the next version of the library.
</Warning>
```csharp
[LamarContainer(typeof(CalculatorRegistry))]
public class TestingCalculatorIntegration : SingletonSuite
{
    private readonly ICalculator calculator;

    public TestingCalculatorIntegration(ICalculator calculator)
    {
        this.calculator = calculator;
    }

    [InlineData(null, 0)]
    [InlineData(new[] { 1d }, 1)]
    [InlineData(new[] { 1d, 2d }, 3)]
    [InlineData(new[] { 1d, 2d, 3d, 4d }, 10)]
    public Fact AdditionHarness(double[] values, double expected)
    {            
        var actual = this.calculator.Apply<AddOperation>(values);
        return (actual == expected, $"Expected {expected} but got {actual}");
    }
}
```

---

Next Section: [Testing a Calculator](/docs/testing-a-calculator/)